= HttpMessage

== httpMessage.Server

TBD

=== Ejemplo de uso con Express

---
http = require 'http-message'

[...]

app = express()
app.use bodyParser.json()
app.use bodyParser.urlencoded({ extended: true })
app.use multer {dest: '/tmp'}
app.use '/section1', mySections.getRouter(1)
app.use '/section2', mySections.getRouter(2)
app.use (req, res, next) -> return res.status(404).send('Not Found')

sepChannel = @offerings['sepdest']

httpServer = http.createServer(@app)
httpServer.on 'error', (err) => logger.error([...])
httpServer.listen sepChannel, (err) => [...]
---

== httpMessage.request()

La función httpMessage.request(options, callback) es equivalente al http.request() de Nodejs.
La única diferencia es que, en lugar de necesitar host+port en su parámetro 'options', necesita un canal de tipo Request.
El envío de la petición y su respuesta, se realizan a través del par REQ->REP de las instancias emisora y receptora.
  Instancia_A+httpMessage.request() --> REQ --> LB --> REP --> httpMessageServer+Instancia_B
Realmente no se utilizan estos canales estáticos, sino 2 pares de canales dinámicos REQ/REP (que simulan un canal dinámico dúplex -- no lo tenemos implementado, y es lo que necesitaríamos).

En options también se puede incluir un objeto httpMessage.Agent, para conseguir que varios peticiones sean sticky respecto a la instancia receptora.
Este objeto httpMessage.Agent es más simple que su equivalente http.Agent de Node, ya que no tiene que gestionar sockets.
En este caso, el concepto de "sticky" se refiere al echo de que dos request's realizadas por una instancia A, sean procesadas por la misma instancia de B.
Un mismo Agent puede utilizarse en varias peticiones Request generadas por A, dirigidas a distintos componentes (el "sticky" será por componente).

Devuelve un objeto request de la clase httpMessage.ClientRequest, con "casi" mismo interfaz que el http.ClientRequest proporcionado por Nodejs.
Hay funcionalidades que no soportamos, como setTimeout() o Abort().

La petición nos proporciona un objeto response de la clase httpMessage.IncomingMessage, equivalente a la clase http.IncomingMessage de Nodejs.
Al igual que en Nodejs, es un stream-readable,


Ejemplo de uso:

----
myAgent = new http.Agent() # Si se quiere sticky

dataToSend = JSON.stringify myObject

options = {
  channel: myRequestChannel
  method: 'POST',
  path: '/upload',
  agent: myAgent  # si quiere (puede no usar agente, o usar el agente global)
  headers: {
    'Content-Type': 'application/json'
  }
}

req = httpMessage.request options, (res) -> {
  res.on 'data', (chunk) ->
    doThings(chunk)
  res.on 'end', () ->
    doThings()

req.on 'error', (e) ->
  doThings(e)

req.write(dataToSend)
req.end()
----
